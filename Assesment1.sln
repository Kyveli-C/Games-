//Kyveli Christoforou
// G21305022//
// Assesment1.cpp: A program using the TL-Engine

#include <TL-Engine.h>	// TL-Engine include file and namespace
#include <iostream>	// TL-Engine include file and namespace
#include <stdio.h>
#include <time.h> //for timer
#include <chrono>

using namespace tle;
using namespace std;

void cameraBehaviour(I3DEngine* myEngine, ICamera* mycamera)
{

	if (myEngine->KeyHeld(Key_2))
	{
		mycamera->ResetOrientation();
		mycamera->SetPosition(150, 150, -150);
		mycamera->RotateX(45);
		mycamera->RotateY(-45);
	}

	if (myEngine->KeyHeld(Key_1))
	{
		mycamera->ResetOrientation();
		mycamera->SetPosition(0, 200, 0);
		mycamera->RotateX(90);
	}
}

bool sphereToBox(IModel* sphere, IModel* cube, float radius, int side)
{
	float dx = sphere->GetLocalX() - cube->GetLocalX();
	float dy = sphere->GetLocalY() - cube->GetLocalY();
	float dz = sphere->GetLocalZ() - cube->GetLocalZ();

	float distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));

	float distanceBetween = radius + (side / 2);
	if (distance < distanceBetween) {

		return true;
	}
	else {
		return false;
	}
}

bool magnet(IModel* sphere, IModel* cube, float radius, int side) {
	float dx = sphere->GetLocalX() - cube->GetLocalX();
	float dy = sphere->GetLocalY() - cube->GetLocalY();
	float dz = sphere->GetLocalZ() - cube->GetLocalZ();

	float distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));

	if (distance <= 50) {
		return true;
	}
	else
	{
		return false;
	}
}

	bool cubeToCube(IModel* cube, IModel* cubeA, int side) {
		float dx = cubeA->GetLocalX() - cube->GetLocalX();
		float dy = cubeA->GetLocalY() - cube->GetLocalY();
		float dz = cubeA->GetLocalZ() - cube->GetLocalZ();

		float distanceApart = sqrt((dx * dx) + (dy * dy) + (dz * dz));

	if (distanceApart <=10) {

			return true;
		}
		return false;

	}

	//automatic movement
	bool movEnemy(IModel* enemy, IModel* cube, float radius, int side) {
		float dx = enemy->GetLocalX() - cube->GetLocalX();
		float dy = enemy->GetLocalY() - cube->GetLocalY();
		float dz = enemy->GetLocalZ() - cube->GetLocalZ();
		
		float distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));

		float distanceBetween = radius + (side / 2);
		if (distance <= 50) {
			return true;
		}
		else
		{
			return false;
		}
	}

	bool sphereToSphere(IModel* sphere, IModel* sphere2, float radius)
	{
		float dx = sphere->GetLocalX() - sphere2->GetLocalX();
		float dy = sphere->GetLocalY() - sphere2->GetLocalY();
		float dz = sphere->GetLocalZ() - sphere2->GetLocalZ();

		float distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));

		float distanceBetween = radius + radius;
		if (distance < distanceBetween) {

			return true;
		}
		else {
			return false;
		}
	}



	void main()
	{
		// Create a 3D engine (using TLX engine here) and open a window for it
		I3DEngine* myEngine = New3DEngine(kTLX);
		myEngine->StartWindowed();

		// Add default folder for meshes and other media
		myEngine->AddMediaFolder(".\\Media");
		myEngine->AddMediaFolder("C:\\ProgramData\\TL-Engine\\Media");


		/**** Set up your scene here ****/

		srand(time(NULL));

		enum gameStates { paused, gameOver, playing, gameWon };
		gameStates state = playing;

		enum ECameraState 
		{ 
			manual, 
			isometric 
		};

		ECameraState activeCamera = manual;

		//camera 
		ICamera* mycamera = myEngine->CreateCamera(kManual);
		mycamera->SetPosition(0, 200, 0);
		mycamera->RotateX(90);
		float kCameraRotation = 1.0f;

		//water  
		IMesh* water = myEngine->LoadMesh("water.x");
		IModel* modelWater = water->CreateModel(0, -5, 0);


		//island
		IMesh* island = myEngine->LoadMesh("island.x");
		IModel* modelIsland = island->CreateModel(0, -5, 0);


		//sphere
		IMesh* sphere = myEngine->LoadMesh("spheremesh.x");
		IModel* modelSphere = sphere->CreateModel(0, 10, 0);


		float kSphereSpeed = 50.0f;
		float kRotationSpeed = 100.0f;
		float kSphereRadius = 10.0f;

		
		bool movingEnemy = true;
		bool isSphereLarger = false;
		bool isEnemySphereLarger = false;


		//sky
		IMesh* sky = myEngine->LoadMesh("sky.x");
		IModel* modelSky = sky->CreateModel(0, -960, 0);


		//random 12 cubes
		const int kcubes = 12;
		IMesh* cube = myEngine->LoadMesh("minicube.x");
		IModel* cubes[kcubes];

		float kCubeSide = 5;
		const float positY = 5.0f;

		for (int i = 0; i < kcubes; i++) {
			float positX = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f; //values -80 to 80
			float positZ = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0;
			cubes[i] = cube->CreateModel(positX, positY, positZ);
		}

		float cubesSpeed = 0.1f;

		//special cube
		IMesh* specialCube = myEngine->LoadMesh("minicube.x");
		float positX = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f; //values -80 to 80
		float positZ = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0;
		IModel* specialCubeModel = specialCube->CreateModel(positX, positY, positZ);
		specialCubeModel->SetSkin("hypercube.jpg");

		float skinChangeTimer = 0.0f; //timer
		bool skinActive = false;
		bool skinEnemyActive = false;

		//enemy sphere
		IMesh* enemySphere = myEngine->LoadMesh("spheremesh.x");
		float positX2 = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f; //values -80 to 80
		float positZ2 = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0;
		IModel* modelEnemySphere = enemySphere->CreateModel(positX2, 10, positZ2);
		modelEnemySphere->SetSkin("enemysphere.jpg");

		
		float kEnemyRotationSpeed = 50.0f;
		

		float movementNPC = static_cast<float>(rand()) / RAND_MAX * 0.1f - 0.05f;
		float movementNPCZ = static_cast<float>(rand()) / RAND_MAX * 0.1f - 0.05f;
	

		//messages to be displayed
		IFont* pointsDisplay = myEngine->LoadFont("Arial", 50); //score
		IFont* winGame = myEngine->LoadFont("Arial", 72); //win
		IFont* endGame = myEngine->LoadFont("Arial", 72); //loose
		IFont* enemyScore = myEngine->LoadFont("Arial", 50); 
		IFont* pause = myEngine->LoadFont("Arial", 50);


		int playerPoints = 0;

		int enemyPoints = 0;

		


		// The main game loop, repeat until engine is stopped
		while (myEngine->IsRunning())
		{
			// Draw the scene
			myEngine->DrawScene();

			float dT = myEngine->Timer();


			

			/**** Update your scene each frame here ****/

			//*********************************************************
			//					PLAYING STATE
			//*********************************************************


			if (state == playing) 
			{

				//camera rotation
				if (activeCamera == manual)
				{
					if (myEngine->KeyHeld(Key_Up)) 
                    {
		              mycamera->MoveZ(kCameraRotation);
					}
					if (myEngine->KeyHeld(Key_Down)) 
					{
						mycamera->MoveZ(-kCameraRotation);
					}
					if (myEngine->KeyHeld(Key_Left)) {
						mycamera->MoveX(-kCameraRotation);
					}
					if (myEngine->KeyHeld(Key_Right)) {
						mycamera->MoveX(kCameraRotation);
					}
				}

			//change camera
				cameraBehaviour(myEngine, mycamera);
			

			//move sphere
			if (myEngine->KeyHeld(Key_W)) 
				{
				modelSphere->MoveLocalZ(kSphereSpeed * dT);
				}
			if (myEngine->KeyHeld(Key_S))
				{
				modelSphere->MoveLocalZ(-kSphereSpeed * dT);
				}
			if (myEngine->KeyHeld(Key_D))
				{
				modelSphere->RotateLocalY(kRotationSpeed * dT);
				}
			if (myEngine->KeyHeld(Key_A)) 
				{
				modelSphere->RotateLocalY(-kRotationSpeed * dT);
				}

			//increase ball size
			if (playerPoints >= 40 && playerPoints<80 && !isSphereLarger)
				{
				modelSphere->Scale(1.2);//change the sphere size when game is won
				modelSphere->SetLocalY(10); // must change position so it's above the set
				isSphereLarger = true;
				}
			if (playerPoints>= 80 && playerPoints<120 && isSphereLarger)
				{
				modelSphere->Scale(1.2);
				modelSphere->SetLocalY(15);
				isSphereLarger = false;
				}
			if (playerPoints >= 120 && !isSphereLarger)		
				{
				modelSphere->Scale(1.2);
				modelSphere->SetLocalY(20);
				isSphereLarger = true;
				}

			//increase enemy size
			if (enemyPoints >= 40 && enemyPoints<80 && !isEnemySphereLarger)
				{
				modelEnemySphere->Scale(1.2);
				modelEnemySphere->SetLocalY(10);
				isEnemySphereLarger = true;
				}
			else if (enemyPoints >= 80 && enemyPoints <120 && isEnemySphereLarger)
				{
				modelEnemySphere->Scale(1.2);
				modelEnemySphere->SetLocalY(15);
				isEnemySphereLarger = false;
				}
			else if (enemyPoints >= 120 && !isEnemySphereLarger)
				{
				modelEnemySphere->Scale(1.2);
				modelEnemySphere->SetLocalY(15);
				isEnemySphereLarger = true;
				}


			//collision of two cubes-draw at another position
			for (int i = 0; i < kcubes; i++) 
			{
				for (int j = i + 1; j < kcubes; j++) 
				{
					if (cubeToCube(cubes[i], cubes[j], kCubeSide))
					{
						float x = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f;
						float z = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f;
						float y = 5.0f;
						cubes[i]->SetPosition(x, y, z);
					}
				}
			}


			//collision sphere to cubes-get points
			for (int i = 0; i < kcubes; i++) {
				if (sphereToBox(modelSphere, cubes[i], kSphereRadius, kCubeSide)) //if collision
				{
					float x = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f;
					float z = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f;
					float y = 5.0f;
					cubes[i]->SetPosition(x, y, z);
					playerPoints += 10;
				}
			}

			//collision enemy to cubes
			for (int i = 0; i < kcubes; i++) {
				if (sphereToBox(modelEnemySphere, cubes[i], kSphereRadius, kCubeSide)) //if collision
				{
					float x = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f;
					float z = static_cast<float>(rand()) / RAND_MAX * 160.0f - 80.0f;
					float y = 5.0f;
					cubes[i]->SetPosition(x, y, z);
					enemyPoints += 10;
				}
			}

			string score;
			score = "Points:" + to_string(playerPoints);


			string scoreEnemy;
			scoreEnemy = "Enemy Points:" + to_string(enemyPoints);


			//show higher score on top
			if (enemyPoints > playerPoints)
			{
				enemyScore->Draw(scoreEnemy.c_str(), 1250, 40, kMagenta, kRight, kTop);
				pointsDisplay->Draw(score.c_str(), 1250, 80, kBlue, kRight, kTop);
			}
			else
			{
				enemyScore->Draw(scoreEnemy.c_str(), 1250, 80, kMagenta, kRight, kTop);
				pointsDisplay->Draw(score.c_str(), 1250, 40, kBlue, kRight, kTop);
			}

			//collision sphere to special cube-change skin
			if (!skinActive && sphereToBox(modelSphere, specialCubeModel, kSphereRadius, kCubeSide)) //if collision
			{
				skinActive = true;
				modelSphere->SetSkin("hypersphere.jpg");
				specialCubeModel->SetPosition(1000, 1000, 1000);
				skinChangeTimer = 0.0f;
			}
			
			if (skinActive) {
				skinChangeTimer += dT;
				cout << skinChangeTimer << endl;

				//sphere attracts cubes
				for (int i = 0; i < kcubes; i++) {
					if (magnet(modelSphere, cubes[i], kSphereRadius, kCubeSide))
					{
						//vectors
						float dx = modelSphere->GetLocalX() - cubes[i]->GetLocalX();
						float dy = modelSphere->GetLocalY() - cubes[i]->GetLocalY();
						float dz = modelSphere->GetLocalZ() - cubes[i]->GetLocalZ();

						float distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));

						float x = dx / distance;
						float y = dy / distance;
						float z = dz / distance;
						
						cubes[i]->MoveX(x);
						cubes[i]->MoveY(y);
						cubes[i]->MoveZ(z);
					}
				}

				if (skinChangeTimer >= 5.0f)
				{
					skinActive = false;
					modelSphere->SetSkin("regularsphere.jpg");

				}
			}

			//same for enemy
			if (!skinEnemyActive && sphereToBox(modelEnemySphere, specialCubeModel, kSphereRadius, kCubeSide)) //if collision
			{
				skinEnemyActive = true;
				modelEnemySphere->SetSkin("hypersphere.jpg");
				specialCubeModel->SetPosition(1000, 1000, 1000);
				skinChangeTimer = 0.0f;
			}
			if (skinEnemyActive)
				{
				skinChangeTimer += dT;
				cout << skinChangeTimer << endl;

				// enemy sphere attracts cubes

				

					for (int i = 0; i < kcubes; i++) 
					{
						if (magnet(modelEnemySphere, cubes[i], kSphereRadius, kCubeSide)) // if distance is <=50
							{
							//vectors
							float dx = modelEnemySphere->GetLocalX() - cubes[i]->GetLocalX();
							float dy = modelEnemySphere->GetLocalY() - cubes[i]->GetLocalY();
							float dz = modelEnemySphere->GetLocalZ() - cubes[i]->GetLocalZ();

							float distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));

							float x = dx / distance;
							float y = dy / distance;
							float z = dz / distance;

							cubes[i]->MoveX(x*cubesSpeed);
							cubes[i]->MoveY(y* cubesSpeed);
							cubes[i]->MoveZ(z* cubesSpeed);
						}
					}

					if (skinChangeTimer >= 5.0f)
						{
						skinEnemyActive = false;
						modelEnemySphere->SetSkin("enemysphere.jpg");
						}
					}

			//enemy moves

			modelEnemySphere->MoveLocalZ(kSphereSpeed * dT);

			modelEnemySphere->MoveLocalZ(-kSphereSpeed * dT);

			modelEnemySphere->RotateLocalY(kRotationSpeed * dT);

			modelEnemySphere->RotateLocalY(-kRotationSpeed * dT);



			if (movingEnemy) 
				{
				modelEnemySphere->MoveX(movementNPC);
				modelEnemySphere->MoveZ(movementNPCZ);

				if (modelEnemySphere->GetLocalX() >= 80)
					{
					movementNPC = static_cast<float>(rand()) / RAND_MAX * 0.1f - 0.05f;
					movementNPC = -movementNPC;
					}
				if (modelEnemySphere->GetLocalX() <= -80) 
					{
					movementNPC = static_cast<float>(rand()) / RAND_MAX * 0.1f - 0.05f;
					movementNPC = movementNPC;
					}
				if (modelEnemySphere->GetLocalZ() <= -80)
					{
					movementNPCZ = static_cast<float>(rand()) / RAND_MAX * 0.1f - 0.05;
					movementNPCZ = movementNPCZ;
					}
				if (modelEnemySphere->GetLocalZ() >= 80)
				{
					movementNPCZ = static_cast<float>(rand()) / RAND_MAX * 0.1f - 0.05f * dT;
					movementNPCZ = -movementNPCZ;
				}

				if (modelEnemySphere->GetZ() > 0 && modelEnemySphere->GetX() > 0)
				{
					modelEnemySphere->RotateLocalY(0.1);
				}
				if (modelEnemySphere->GetZ() < 0 && modelEnemySphere->GetX() > 0)
				{
					modelEnemySphere->RotateLocalY(0.1);
				}
				if (modelEnemySphere->GetZ() > 0 && modelEnemySphere->GetX() > 0)
				{
					modelEnemySphere->RotateLocalY(-0.1);
				}
				if (modelEnemySphere->GetZ() < 0 && modelEnemySphere->GetX() < 0)
				{
					modelEnemySphere-> RotateLocalY(-0.1);
				}
	
				}
			

			// bounce spheres

			if (sphereToSphere(modelSphere, modelEnemySphere, kSphereRadius))
			{
				if (abs(playerPoints - enemyPoints) <= 40)
				{
					float sphereX=modelSphere->GetX();
					float sphereZ = modelSphere->GetZ();
					float enemyX = modelEnemySphere->GetX();
					float enemyZ = modelEnemySphere->GetZ();

					if (sphereX > enemyX) 
						{
						modelSphere->MoveX(10);
						modelEnemySphere->MoveX(-10);
						}
					if (sphereX < enemyX)
						{
						modelSphere->MoveX(-10);
						modelEnemySphere->MoveX(10);
						}
					if (sphereZ > enemyZ) 
						{
						modelSphere->MoveZ(10);
						modelEnemySphere->MoveZ(-10);
						}
	
					if (sphereZ > enemyZ) 
						{
					modelSphere->MoveZ(10);
					modelEnemySphere->MoveZ(-10);
						}
					}
				else if (playerPoints > enemyPoints)
				{
					playerPoints += 40;
					modelEnemySphere->SetPosition(1000, 1000, 1000);
					modelSphere->Scale(1.2);
				}
				else if (playerPoints < enemyPoints)
				{
					enemyPoints += 40;
					modelSphere->SetPosition(1000, 1000, 1000);
					modelEnemySphere->Scale(1.2);
					state = gameOver;
				}

			}



			// CHANGE STATE:
			 //pause game
			if (myEngine->KeyHit(Key_P))
			{
				state = paused;

			}

			//game won
			if (playerPoints >= 120)
			{
				state = gameWon;
			}
			else if (enemyPoints >= 120)
			{
				state = gameOver;
			}


			//game over when ball enters in the water
			if (modelSphere->GetLocalX() <= -100 || modelSphere->GetLocalX() >= 100
				|| modelSphere->GetLocalZ() <= -100 || modelSphere->GetLocalZ() >= 100)
			{
				state = gameOver;
			}
			
		}

			//*********************************************************
			//					GAME WON STATE
			//*********************************************************

			//win the game
			if (state == gameWon)
			{
				string win = "Congratulations! You won!";
				winGame->Draw(win, 640, 320, kBlue, kCentre, kVCentre);
				movingEnemy = true;	
			}

			

			//*********************************************************
			//					GAME OVER STATE
			//*********************************************************
			if (state == gameOver)
			{
				string end = "Game Over!";
				endGame->Draw(end, 640, 320, kMagenta, kCentre, kVCentre);
				movingEnemy = true;
			}
		

		//*********************************************************
		//					PAUSED STATE
		//*********************************************************
		if (state == paused)
		{
		  if (myEngine->KeyHit(Key_P))
			{
				state = playing;
			}
		  string pauseMessage = " Game Paused!";
		  pause->Draw(pauseMessage, 640, 320, kBlue, kCentre, kVCentre);
		}

		if (state != paused)
		{
			modelEnemySphere->MoveLocalZ(kSphereSpeed * dT);

			modelEnemySphere->MoveLocalZ(-kSphereSpeed * dT);

			modelEnemySphere->RotateLocalY(kRotationSpeed * dT);

			modelEnemySphere->RotateLocalY(-kRotationSpeed * dT);



			if (movingEnemy) {
				modelEnemySphere->MoveX(movementNPC);
				modelEnemySphere->MoveZ(movementNPCZ);

				if (modelEnemySphere->GetLocalX() >= 80) {
					movementNPC = static_cast<float>(rand()) / RAND_MAX * 0.5f - 0.1f;
					movementNPC = -movementNPC;
				}
				if (modelEnemySphere->GetLocalX() <= -80) {
					movementNPC = static_cast<float>(rand()) / RAND_MAX * 0.5f - 0.1f;
					movementNPC = movementNPC;
				}
				if (modelEnemySphere->GetLocalZ() <= -80) {
					movementNPCZ = static_cast<float>(rand()) / RAND_MAX * 0.5f - 0.1f;
					movementNPCZ = movementNPCZ;
				}
				if (modelEnemySphere->GetLocalZ() >= 80) {
					movementNPCZ = static_cast<float>(rand()) / RAND_MAX * 0.5f - 0.1f;
					movementNPCZ = -movementNPCZ;
				}
			}
		}
			
		

		//exit game
		if (myEngine->KeyHit(Key_Escape))
		{
			myEngine->Stop();
		}

	}
	
	// Delete the 3D engine now we are finished with it
	myEngine->Delete();
}

